<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NonlinearEquations · ModiaMath</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ModiaMath</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/Overview.html">Overview</a></li><li><a class="toctext" href="../man/Plans.html">Plans for version 1.0</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="SimulationEngine.html">SimulationEngine</a></li><li><a class="toctext" href="Result.html">Result</a></li><li><a class="toctext" href="DAE.html">DAE</a></li><li class="current"><a class="toctext" href="NonlinearEquations.html">NonlinearEquations</a><ul class="internal"></ul></li><li><a class="toctext" href="Variables.html">Variables</a></li><li><a class="toctext" href="Logging.html">Logging</a></li><li><a class="toctext" href="Frames.html">Frames</a></li><li><a class="toctext" href="Utilities.html">Utilities</a></li><li><a class="toctext" href="ModiaMath.html">Constants and Types</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="NonlinearEquations.html">NonlinearEquations</a></li></ul><a class="edit-page" href="https://github.com/ModiaSim/ModiaMath.jl/blob/master/docs/src/lib/NonlinearEquations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>NonlinearEquations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="NonlinearEquations-1" href="#NonlinearEquations-1">NonlinearEquations</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.NonlinearEquations" href="#ModiaMath.NonlinearEquations"><code>ModiaMath.NonlinearEquations</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-julia">module ModiaMath.NonlinearEquations</code></pre><p>This module contains functions to solve nonlinear algebraic equations:</p><ul><li><p><a href="NonlinearEquations.html#ModiaMath.NonlinearEquations.solveOneNonlinearEquation-Tuple{Function,Any,Any}"><code>solveOneNonlinearEquation</code></a>: Function that computes the solution of one non-linear algebraic equation <code>y=f(u)</code> in one unknown <code>u</code> in a reliable and efficient way using Brents algorithm.</p></li><li><p><a href="NonlinearEquations.html#ModiaMath.NonlinearEquations.KINSOL"><code>KINSOL</code></a>: Module containing functions to solve a system of nonlinear systems of equations with Sundials KINSOL. The module is designed so that the same system is solved several times with KINSOL as needed by Modia simulations (auxiliary memory is only allocated once and not for every call). KINSOL is used in ModiaMath to solve nonlinear algebraic equations during initialization and at events of a simulation.</p></li></ul><p><strong>Main developer</strong></p><p><a href="https://rmc.dlr.de/sr/de/staff/martin.otter/">Martin Otter</a>, <a href="https://www.dlr.de/sr/en">DLR - Institute of System Dynamics and Control</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/1de8ab84ab40cece69506376acc513aeb78948bf/src/NonlinearEquations/_module.jl#L4-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.NonlinearEquations.solveOneNonlinearEquation-Tuple{Function,Any,Any}" href="#ModiaMath.NonlinearEquations.solveOneNonlinearEquation-Tuple{Function,Any,Any}"><code>ModiaMath.NonlinearEquations.solveOneNonlinearEquation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">y = solveOneNonlinearEquation(f, u_min, u_max; u_nominal=1.0, tolerance=100.0*eps())</code></pre><p>This function determines the solution of one non-linear algebraic equation <code>y=f(u)</code> in one unknown <code>u</code> in a reliable and efficient way. It is one of the best numerical algorithms for this purpose. As input, the nonlinear function <code>f(u)</code> has to be given, as well as an interval <code>u_min</code>, <code>u_max</code> that contains the solution, that is <code>f(u_min)</code> and <code>f(u_max)</code> must have a different sign.  The function computes iteratively smaller intervals in which a sign change is present and terminates when the following test is fulfilled (<code>u_nominal</code> is the nominal value of <code>u</code>, so the order of magnitude of <code>u</code> around the solution and <code>tolerance</code> is the relative tolerance; for example, tolerance=1e-10 means that the solution is correct up to 10 digits):</p><pre><code class="language-none">absTol = 0.1*u_nominal*tolerance
if abs(length_of_u_interval) &lt;= max(tolerance*abs(u), absTol) || f(u) == 0.0
    # root u found (interval is small enough)</code></pre><p>The interval reduction is performed using inverse quadratic interpolation (interpolating with a quadratic polynomial through the last three points and computing the zero). If this fails, bisection is used, which always reduces the interval by a factor of two. The inverse quadratic interpolation method has superlinear convergence. This is roughly the same convergence rate as a globally convergent Newton method, but without the need to compute derivatives of the non-linear function. The solver function is a direct mapping of the Algol 60 procedure <code>zero</code> to Julia, from:</p><ul><li>Brent R.P. (1973): <em>Algorithms for Minimization without derivatives.</em> Prentice Hall, 1973, pp. 58-59.<br/>Download: <a href="http://wwwmaths.anu.edu.au/~brent/pd/rpb011i.pdf">http://wwwmaths.anu.edu.au/~brent/pd/rpb011i.pdf</a><br/>Errata and new print: <a href="http://wwwmaths.anu.edu.au/~brent/pub/pub011.html">http://wwwmaths.anu.edu.au/~brent/pub/pub011.html</a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">import ModiaMath: solveOneNonlinearEquation

fun(u; w=1.0) = 3*u - sin(w*u) - 1
u_zero = solveOneNonlinearEquation(u-&gt;fun(u; w=3.0), 0.0, 5.0)
println(&quot;residue = &quot;, fun(u_zero; w=3.0))</code></pre><p><strong>Remarks</strong></p><ul><li><p>The interface was made such that it is identical to function <a href="https://doc.modelica.org/Modelica%203.2.3/Resources/helpDymola/Modelica_Math_Nonlinear.html#Modelica.Math.Nonlinear.solveOneNonlinearEquation">Modelica.Math.Nonlinear.solveOneNonlinearEquation</a> in order that automatic translation of Modelica to Modia is simplified. However, the termination condition was changed: The original Brent algorithm uses an absolute tolerance for termination (abs(length<em>of</em>interval) &lt;= 2<em>eps()</em>abs(u) + tolerance || f(u) == 0.0), whereas this was changed here to take a relative tolerance into account and use a similar definition of tolerances as used by Modia and Modelica, because easier to understand by a user (with relative tolerance and nominal value, instead of relative and absolute tolerances).</p></li><li><p>Newer algorithms for the problem are presented in <em>Alefeld, Potra, Shi (1995):</em> <a href="https://dl.acm.org/citation.cfm?id=210111">Algorithm 748: enclosing zeros of continuous functions</a>. Here, an inverse cubic interpolation is used instead of an inverse quadratic interpolation as in case of the Brent algorithm. The numerical experiments in this article with 15 test problems show that Brents algorithm needs about 5% more function evaluations for all the 15 test problems as the newly presented algorithm 4.2 (in some cases Brents algorithm needs slightly less and in other cases slightly more function evaluations).</p></li><li><p>Julia package <a href="https://github.com/JuliaMath/Roots.jl">Roots.jl</a> provides various algorithms to solve the problem above but it seems that Brents algorithm is not yet included (as of Nov. 2018).</p></li></ul><p>```</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/1de8ab84ab40cece69506376acc513aeb78948bf/src/NonlinearEquations/solveOneNonlinearEquation.jl#L8-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.NonlinearEquations.KINSOL" href="#ModiaMath.NonlinearEquations.KINSOL"><code>ModiaMath.NonlinearEquations.KINSOL</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-julia">module KINSOL - Solve nonlinear equation system with Sundials KINSOL</code></pre><p>The goal is to solve the same system several times with KINSOL.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/1de8ab84ab40cece69506376acc513aeb78948bf/src/NonlinearEquations/sundials_kinsol.jl#L8-L12">source</a></section><footer><hr/><a class="previous" href="DAE.html"><span class="direction">Previous</span><span class="title">DAE</span></a><a class="next" href="Variables.html"><span class="direction">Next</span><span class="title">Variables</span></a></footer></article></body></html>
